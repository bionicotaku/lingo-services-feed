// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: videos_projection.sql

package feeddb

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getVideoProjection = `-- name: GetVideoProjection :one
select
  video_id,
  title,
  description,
  duration_micros,
  thumbnail_url,
  hls_master_playlist,
  status,
  visibility_status,
  published_at,
  version,
  updated_at
from feed.videos_projection
where video_id = $1
`

func (q *Queries) GetVideoProjection(ctx context.Context, videoID uuid.UUID) (FeedVideosProjection, error) {
	row := q.db.QueryRow(ctx, getVideoProjection, videoID)
	var i FeedVideosProjection
	err := row.Scan(
		&i.VideoID,
		&i.Title,
		&i.Description,
		&i.DurationMicros,
		&i.ThumbnailUrl,
		&i.HlsMasterPlaylist,
		&i.Status,
		&i.VisibilityStatus,
		&i.PublishedAt,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const listVideoProjections = `-- name: ListVideoProjections :many
select
  video_id,
  title,
  description,
  duration_micros,
  thumbnail_url,
  hls_master_playlist,
  status,
  visibility_status,
  published_at,
  version,
  updated_at
from feed.videos_projection
where video_id = any($1::uuid[])
`

func (q *Queries) ListVideoProjections(ctx context.Context, dollar_1 []uuid.UUID) ([]FeedVideosProjection, error) {
	rows, err := q.db.Query(ctx, listVideoProjections, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FeedVideosProjection{}
	for rows.Next() {
		var i FeedVideosProjection
		if err := rows.Scan(
			&i.VideoID,
			&i.Title,
			&i.Description,
			&i.DurationMicros,
			&i.ThumbnailUrl,
			&i.HlsMasterPlaylist,
			&i.Status,
			&i.VisibilityStatus,
			&i.PublishedAt,
			&i.Version,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVideoProjection = `-- name: UpsertVideoProjection :exec
insert into feed.videos_projection (
  video_id,
  title,
  description,
  duration_micros,
  thumbnail_url,
  hls_master_playlist,
  status,
  visibility_status,
  published_at,
  version,
  updated_at
)
values (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  coalesce($11, now())
)
on conflict (video_id) do update
set title               = excluded.title,
    description         = excluded.description,
    duration_micros     = excluded.duration_micros,
    thumbnail_url       = excluded.thumbnail_url,
    hls_master_playlist = excluded.hls_master_playlist,
    status              = excluded.status,
    visibility_status   = excluded.visibility_status,
    published_at        = excluded.published_at,
    version             = excluded.version,
    updated_at          = excluded.updated_at
`

type UpsertVideoProjectionParams struct {
	VideoID           uuid.UUID          `json:"video_id"`
	Title             string             `json:"title"`
	Description       pgtype.Text        `json:"description"`
	DurationMicros    pgtype.Int8        `json:"duration_micros"`
	ThumbnailUrl      pgtype.Text        `json:"thumbnail_url"`
	HlsMasterPlaylist pgtype.Text        `json:"hls_master_playlist"`
	Status            pgtype.Text        `json:"status"`
	VisibilityStatus  pgtype.Text        `json:"visibility_status"`
	PublishedAt       pgtype.Timestamptz `json:"published_at"`
	Version           int64              `json:"version"`
	Column11          interface{}        `json:"column_11"`
}

func (q *Queries) UpsertVideoProjection(ctx context.Context, arg UpsertVideoProjectionParams) error {
	_, err := q.db.Exec(ctx, upsertVideoProjection,
		arg.VideoID,
		arg.Title,
		arg.Description,
		arg.DurationMicros,
		arg.ThumbnailUrl,
		arg.HlsMasterPlaylist,
		arg.Status,
		arg.VisibilityStatus,
		arg.PublishedAt,
		arg.Version,
		arg.Column11,
	)
	return err
}
