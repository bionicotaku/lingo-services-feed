// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recommendation_logs.sql

package feeddb

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getRecommendationLog = `-- name: GetRecommendationLog :one
select
  log_id,
  user_id,
  request_limit,
  recommendation_source,
  recommendation_latency_ms,
  recommended_items,
  missing_video_ids,
  error_kind,
  generated_at
from feed.recommendation_logs
where log_id = $1
`

func (q *Queries) GetRecommendationLog(ctx context.Context, logID uuid.UUID) (FeedRecommendationLog, error) {
	row := q.db.QueryRow(ctx, getRecommendationLog, logID)
	var i FeedRecommendationLog
	err := row.Scan(
		&i.LogID,
		&i.UserID,
		&i.RequestLimit,
		&i.RecommendationSource,
		&i.RecommendationLatencyMs,
		&i.RecommendedItems,
		&i.MissingVideoIds,
		&i.ErrorKind,
		&i.GeneratedAt,
	)
	return i, err
}

const insertRecommendationLog = `-- name: InsertRecommendationLog :exec
insert into feed.recommendation_logs (
  user_id,
  request_limit,
  recommendation_source,
  recommendation_latency_ms,
  recommended_items,
  missing_video_ids,
  error_kind,
  generated_at
)
values (
  $1,
  $2,
  $3,
  $4,
  coalesce($5, '[]'::jsonb),
  coalesce($6, '[]'::jsonb),
  $7,
  coalesce($8, now())
)
`

type InsertRecommendationLogParams struct {
	UserID                  pgtype.Text `json:"user_id"`
	RequestLimit            int32       `json:"request_limit"`
	RecommendationSource    string      `json:"recommendation_source"`
	RecommendationLatencyMs pgtype.Int4 `json:"recommendation_latency_ms"`
	RecommendedItems        interface{} `json:"recommended_items"`
	MissingVideoIds         interface{} `json:"missing_video_ids"`
	ErrorKind               pgtype.Text `json:"error_kind"`
	GeneratedAt             interface{} `json:"generated_at"`
}

func (q *Queries) InsertRecommendationLog(ctx context.Context, arg InsertRecommendationLogParams) error {
	_, err := q.db.Exec(ctx, insertRecommendationLog,
		arg.UserID,
		arg.RequestLimit,
		arg.RecommendationSource,
		arg.RecommendationLatencyMs,
		arg.RecommendedItems,
		arg.MissingVideoIds,
		arg.ErrorKind,
		arg.GeneratedAt,
	)
	return err
}

const listRecommendationLogs = `-- name: ListRecommendationLogs :many
select
  log_id,
  user_id,
  request_limit,
  recommendation_source,
  recommendation_latency_ms,
  recommended_items,
  missing_video_ids,
  error_kind,
  generated_at
from feed.recommendation_logs
where
  ($1::text is null or user_id = $1) and
  ($2::text is null or recommendation_source = $2) and
  ($3::timestamptz is null or generated_at >= $3) and
  ($4::timestamptz is null or generated_at < $4)
order by generated_at desc
limit $5
`

type ListRecommendationLogsParams struct {
	UserID   pgtype.Text        `json:"user_id"`
	Source   pgtype.Text        `json:"source"`
	Since    pgtype.Timestamptz `json:"since"`
	Until    pgtype.Timestamptz `json:"until"`
	RowLimit int32              `json:"row_limit"`
}

func (q *Queries) ListRecommendationLogs(ctx context.Context, arg ListRecommendationLogsParams) ([]FeedRecommendationLog, error) {
	rows, err := q.db.Query(ctx, listRecommendationLogs,
		arg.UserID,
		arg.Source,
		arg.Since,
		arg.Until,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FeedRecommendationLog{}
	for rows.Next() {
		var i FeedRecommendationLog
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.RequestLimit,
			&i.RecommendationSource,
			&i.RecommendationLatencyMs,
			&i.RecommendedItems,
			&i.MissingVideoIds,
			&i.ErrorKind,
			&i.GeneratedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
